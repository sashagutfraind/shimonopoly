<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shimonopoly - Power Restoration Game</title>
    <!-- AWS SDK for JavaScript -->
    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1691.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
        }

        .screen {
            display: none;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            padding: 40px;
            max-width: 800px;
            width: 100%;
        }

        .screen.active {
            display: block;
        }
        
        /* Full-screen game screen */
        #gameScreen.active {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            max-width: none;
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        h2 {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.2em;
            font-weight: normal;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }

        input[type="text"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
            font-family: monospace;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .error-message {
            color: #e74c3c;
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        /* Game Screen Styles */
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            flex-shrink: 0;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-top: 5px;
        }

        #gameCanvas {
            width: 100%;
            flex: 1;
            min-height: 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #f0f8ff;
            display: block;
            cursor: crosshair;
        }

        .canvas-wrapper {
            flex: 1;
            min-height: 0;
            overflow: hidden;
            display: flex;
        }

        .input-area {
            display: flex;
            gap: 10px;
            flex-shrink: 0;
        }

        .input-area input {
            flex: 1;
        }

        /* End Screen Styles */
        .score-display {
            text-align: center;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .final-score {
            font-size: 48px;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }

        .score-label {
            font-size: 18px;
            color: #666;
        }

        .leaderboard {
            margin-top: 30px;
        }

        .leaderboard h3 {
            color: #333;
            margin-bottom: 15px;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        .leaderboard-entry:last-child {
            border-bottom: none;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .button-group button {
            flex: 1;
        }

        /* Hide AWS credentials field and its container */
        .form-group:has(#awsCredentials) {
            display: none;
        }

        /* Fireworks styles */
        #fireworks {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9999;
        }

        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: explode 1s ease-out forwards;
        }

        @keyframes explode {
            0% {
                transform: translate(0, 0);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty));
                opacity: 0;
            }
        }

        /* Advanced settings collapsible section */
        .advanced-settings-toggle {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 14px;
            padding: 10px 0;
            text-decoration: underline;
            margin-bottom: 10px;
        }

        .advanced-settings-toggle:hover {
            transform: none;
            box-shadow: none;
            color: #764ba2;
        }

        .advanced-settings {
            display: none;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 20px;
            background: #f8f9fa;
        }

        .advanced-settings.show {
            display: block;
        }

        .advanced-settings h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #555;
            font-size: 16px;
        }

        /* Mobile responsiveness for narrow displays */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .screen {
                padding: 20px;
            }

            #gameScreen.active {
                padding: 10px;
            }

            h1 {
                font-size: 1.8em;
            }

            h2 {
                font-size: 1em;
            }

            /* Enable horizontal scrolling for map on mobile */
            .canvas-wrapper {
                overflow-x: auto;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            }

            #gameCanvas {
                min-width: 600px; /* Maintain aspect ratio - map won't be squeezed */
                width: auto;
                height: 100%;
            }

            /* Stack input and button vertically on mobile */
            .input-area {
                flex-direction: column;
            }

            .input-area input {
                width: 100%;
            }

            .input-area button {
                width: 100%;
            }

            /* Reduce stat font sizes for better fit */
            .stat-label {
                font-size: 10px;
            }

            .stat-value {
                font-size: 18px;
            }

            /* Reduce game container gap */
            .game-container {
                gap: 10px;
            }

            /* Reduce stats padding */
            .game-stats {
                padding: 10px;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <!-- Setup Screen -->
    <div id="setupScreen" class="screen active">
        <h1>Shimonopoly</h1>
        <h2>Restore power to cities affected by a solar storm while learning to spell (ages 4-6) </h2>
        
        <div class="form-group">
            <label for="playerName">Player Name</label>
            <input type="text" id="playerName" value="Player" placeholder="Enter your name" required>
        </div>

        <div class="form-group">
            <label for="country">Country</label>
            <select id="country" required>
                <option value="usa">USA</option>
                <option value="world">World</option>
            </select>
        </div>

        <div class="form-group">
            <label for="numCities">Number of Cities</label>
            <input type="number" id="numCities" value="50" min="1" required>
        </div>

        <button type="button" class="advanced-settings-toggle" id="advancedSettingsToggle">More settings</button>
        <div class="advanced-settings" id="advancedSettings">
            <h3>Advanced Settings</h3>
            
            <div class="form-group">
                <label for="randomSeed">Random Seed</label>
                <input type="number" id="randomSeed" value="42" required>
            </div>

            <div class="form-group">
                <label for="damagedFraction">Fraction of Cities Damaged (0.5 - 1.0)</label>
                <input type="number" id="damagedFraction" value="1.0" min="0.5" max="1.0" step="0.1" required>
                <div class="error-message" id="damagedFractionError">Fraction must be between 0.5 and 1.0</div>
            </div>

            <div class="form-group">
                <label for="timerDuration">Timer Duration (seconds)</label>
                <input type="number" id="timerDuration" value="300" min="1" required>
            </div>
        </div>

        <div class="form-group checkbox-group">
            <input type="checkbox" id="advancedMode">
            <label for="advancedMode">Enable Advanced Mode (population-based scoring & distance-based costs)</label>
        </div>

        <br/>

        <div class="form-group">
            <label for="awsCredentials">AWS Credentials (Optional, JSON format)</label>
            <textarea id="awsCredentials" placeholder='{"accessKeyId": "...", "secretAccessKey": "...", "region": "us-east-1"}'></textarea>
        </div>

        <button type="button" id="startButton">Start Game</button>
        
        <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; font-size: 12px; color: #888;">
            <p style="margin: 5px 0;">Concept and code © 2026 <a href="https://www.linkedin.com/in/gutfraind/"> Alexander Gutfraind</a> - <a href="https://creativecommons.org/licenses/by-nc/4.0/">Licensed CC SA-NC </a>. Inspired by collaborative <a href="https://academic.oup.com/comnet/article-abstract/4/2/177/2196849" target="_blank" style="color: #667eea;">Research paper</a></p>
            <p style="margin: 5px 0;">Map data by <a href="https://simplemaps.com/data/us-cities" target="_blank" style="color: #667eea;">simplemaps.com</a></p>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="screen">
        <div class="game-container">
            <div class="game-stats">
                <div class="stat">
                    <div class="stat-label">Time</div>
                    <div class="stat-value" id="timerDisplay">0:00</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="scoreDisplay">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Energy</div>
                    <div class="stat-value" id="transformersDisplay">0</div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="gameCanvas"></canvas>
            </div>

            <div class="input-area">
                <input type="text" id="cityInput" placeholder="Enter city name to fix ..." autocomplete="off">
                <button id="submitCity">Fix city</button>
            </div>
        </div>
    </div>

    <!-- End Screen -->
    <div id="endScreen" class="screen">
        <h1 id="endScreenTitle">Game Over!</h1>
        
        <div class="score-display">
            <div class="score-label">Final Score</div>
            <div class="final-score" id="finalScore">0</div>
            <div class="score-label">Cities Restored: <span id="citiesRestored">0</span></div>
        </div>

        <!-- Fireworks container -->
        <div id="fireworks" style="display: none;"></div>

        <div class="button-group">
            <button id="saveScoreButton" style="display: none;">Save Score</button>
            <button id="playAgainButton">Play Again</button>
        </div>

        <div class="leaderboard" id="leaderboard" style="display: none;">
            <h3>Leaderboard</h3>
            <div id="leaderboardEntries"></div>
        </div>

        <div class="error-message" id="endScreenError"></div>
    </div>

    <script>
        // ============================================
        // Core Utility Classes
        // ============================================

        /**
         * SeededRandom - Deterministic random number generator
         * Uses a simple Linear Congruential Generator (LCG) algorithm
         */
        class SeededRandom {
            constructor(seed) {
                this.seed = seed % 2147483647;
                if (this.seed <= 0) this.seed += 2147483646;
            }

            /**
             * Generate next random number between 0 and 1
             * @returns {number} Random number in range [0, 1)
             */
            next() {
                this.seed = (this.seed * 16807) % 2147483647;
                return (this.seed - 1) / 2147483646;
            }

            /**
             * Shuffle array in place using Fisher-Yates algorithm
             * @param {Array} array - Array to shuffle
             * @returns {Array} The shuffled array (same reference)
             */
            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(this.next() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }

        /**
         * DistanceCalculator - Calculate distances between geographic coordinates
         */
        class DistanceCalculator {
            static EARTH_RADIUS_MILES = 3959;

            /**
             * Calculate distance between two points using Haversine formula
             * @param {number} lat1 - Latitude of first point in degrees
             * @param {number} lon1 - Longitude of first point in degrees
             * @param {number} lat2 - Latitude of second point in degrees
             * @param {number} lon2 - Longitude of second point in degrees
             * @returns {number} Distance in miles
             */
            static calculateDistance(lat1, lon1, lat2, lon2) {
                // Convert degrees to radians
                const toRad = (deg) => deg * Math.PI / 180;
                
                const lat1Rad = toRad(lat1);
                const lat2Rad = toRad(lat2);
                const deltaLat = toRad(lat2 - lat1);
                const deltaLon = toRad(lon2 - lon1);

                // Haversine formula
                const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                         Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                         Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
                
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                
                return DistanceCalculator.EARTH_RADIUS_MILES * c;
            }

            /**
             * Find all cities within a specified radius of a center city
             * @param {Object} centerCity - City object with lat and lon properties
             * @param {Array} allCities - Array of city objects to search
             * @param {number} radiusMiles - Radius in miles
             * @returns {Array} Array of cities within the radius
             */
            static findCitiesWithinRadius(centerCity, allCities, radiusMiles) {
                return allCities.filter(city => {
                    if (city === centerCity) return false;
                    const distance = DistanceCalculator.calculateDistance(
                        centerCity.lat, centerCity.lon,
                        city.lat, city.lon
                    );
                    return distance <= radiusMiles;
                });
            }
        }

        // Embedded city data - avoids CORS issues when opening file directly
        // ============================================
        // Data Loading
        // ============================================

        /**
         * DataLoader - Load and parse city data from JSONL file
         */
        class DataLoader {
            /**
             * Load city data from a JSONL file
             * @param {string} url - URL or path to the JSONL file
             * @returns {Promise<Array>} Promise resolving to array of city objects
             */
            static async loadCityData(url) {
                console.log('Loading city data from:', url);
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Failed to load city data: ${response.status} ${response.statusText}`);
                    }
                    
                    const text = await response.text();
                    const cities = [];
                    const lines = text.split('\n');
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        
                        // Skip empty lines
                        if (!line) continue;
                        
                        try {
                            const city = JSON.parse(line);
                            
                            // Validate required fields
                            if (!DataLoader.isValidCity(city)) {
                                console.warn(`Skipping malformed city record at line ${i + 1}:`, line);
                                continue;
                            }
                            
                            // Initialize city state
                            cities.push({
                                name: city.name,
                                population: city.population,
                                lat: city.lat,
                                lon: city.lon,
                                damaged: false,
                                restored: false
                            });
                        } catch (parseError) {
                            console.warn(`Skipping invalid JSON at line ${i + 1}:`, line);
                            continue;
                        }
                    }
                    
                    if (cities.length === 0) {
                        throw new Error('No valid city records found in data file');
                    }
                    
                    console.log(`Loaded ${cities.length} cities from ${url}`);
                    return cities;
                    
                } catch (error) {
                    console.error('Error loading city data:', error);
                    throw error;
                }
            }
            
            /**
             * Validate that a city object has all required fields
             * @param {Object} city - City object to validate
             * @returns {boolean} True if city has all required fields with valid types
             */
            static isValidCity(city) {
                if (!city || typeof city !== 'object') return false;
                
                // Check required fields exist
                if (!city.name || !city.hasOwnProperty('population') || 
                    !city.hasOwnProperty('lat') || !city.hasOwnProperty('lon')) {
                    return false;
                }
                
                // Check field types
                if (typeof city.name !== 'string') return false;
                if (typeof city.population !== 'number' || isNaN(city.population)) return false;
                if (typeof city.lat !== 'number' || isNaN(city.lat)) return false;
                if (typeof city.lon !== 'number' || isNaN(city.lon)) return false;
                
                // Check coordinate ranges
                if (city.lat < -90 || city.lat > 90) return false;
                if (city.lon < -180 || city.lon > 180) return false;
                
                return true;
            }
        }

        // ============================================
        // City Management
        // ============================================

        /**
         * CityManager - Manage city selection, damage assignment, and lookup
         */
        class CityManager {
            /**
             * Create a CityManager
             * @param {Array} cities - Array of city objects
             * @param {number} randomSeed - Seed for random number generation
             */
            constructor(cities, randomSeed) {
                this.allCities = cities;
                this.random = new SeededRandom(randomSeed);
                this.cities = [];
            }

            /**
             * Select a random subset of cities
             * @param {number} count - Number of cities to select
             * @returns {Array} Array of selected cities
             */
            selectCities(count) {
                // If count is greater than available cities, use all cities
                const actualCount = Math.min(count, this.allCities.length);
                
                // Sort cities by population (descending) and take the top N
                const sortedByPopulation = [...this.allCities].sort((a, b) => b.population - a.population);
                this.cities = sortedByPopulation.slice(0, actualCount);
                
                return this.cities;
            }

            /**
             * Mark a fraction of cities as damaged
             * @param {number} fraction - Fraction of cities to damage (0.5 to 1.0)
             */
            damageCities(fraction) {
                // Validate fraction
                if (fraction < 0.5 || fraction > 1.0) {
                    throw new Error('Damage fraction must be between 0.5 and 1.0');
                }
                
                // Calculate number of cities to damage
                const numToDamage = Math.round(this.cities.length * fraction);
                
                // Create a copy of cities array and shuffle it
                const shuffled = [...this.cities];
                this.random.shuffle(shuffled);
                
                // Mark the first numToDamage cities as damaged
                for (let i = 0; i < numToDamage; i++) {
                    shuffled[i].damaged = true;
                }
            }

            /**
             * Find a city by name (case-insensitive)
             * @param {string} name - City name to search for
             * @returns {Object|null} City object if found, null otherwise
             */
            findCityByName(name) {
                if (!name || typeof name !== 'string') {
                    return null;
                }
                
                const searchName = name.trim().toLowerCase();
                
                return this.cities.find(city => 
                    city.name.toLowerCase() === searchName
                ) || null;
            }

            /**
             * Get all damaged cities
             * @returns {Array} Array of damaged cities
             */
            getDamagedCities() {
                return this.cities.filter(city => city.damaged && !city.restored);
            }

            /**
             * Get all restored cities
             * @returns {Array} Array of restored cities
             */
            getRestoredCities() {
                return this.cities.filter(city => city.restored);
            }

            /**
             * Get all cities
             * @returns {Array} Array of all cities
             */
            getCities() {
                return this.cities;
            }
        }

        // ============================================
        // Scoring Engine
        // ============================================

        /**
         * ScoringEngine - Calculate points and restoration costs
         */
        class ScoringEngine {
            /**
             * Create a ScoringEngine
             * @param {boolean} advancedMode - Whether advanced mode is enabled
             */
            constructor(advancedMode) {
                this.advancedMode = advancedMode;
            }

            /**
             * Calculate points earned for restoring a city
             * @param {Object} city - City object with population property
             * @returns {number} Points earned
             */
            calculatePoints(city) {
                if (this.advancedMode) {
                    // Advanced mode: population / 1000
                    return city.population / 1000;
                } else {
                    // Basic mode: 1 point per city
                    return 1;
                }
            }

            /**
             * Calculate restoration cost for a city
             * @param {Object} city - City being restored
             * @param {Array} restoredCities - Array of already restored cities
             * @returns {number} Transformer cost
             */
            calculateRestorationCost(city, restoredCities) {
                if (this.advancedMode) {
                    // Advanced mode: 1 / (1 + count of restored cities within 300 miles)
                    const citiesWithin300Miles = DistanceCalculator.findCitiesWithinRadius(
                        city,
                        restoredCities,
                        300
                    );
                    const count = citiesWithin300Miles.length;
                    return 1 / (1 + count);
                } else {
                    // Basic mode: 1 transformer per city
                    return 1;
                }
            }
        }

        // ============================================
        // Game Controller
        // ============================================

        /**
         * GameController - Manages game state and coordinates game logic
         */
        class GameController {
            /**
             * Create a GameController
             * @param {Object} config - Game configuration object
             */
            constructor(config) {
                this.config = config;
                this.cityManager = null;
                this.scoringEngine = null;
                this.state = {
                    transformers: 0,
                    score: 0,
                    timeRemaining: config.timerDuration,
                    timerStarted: false,
                    gameEnded: false
                };
                this.timerInterval = null;
            }

            /**
             * Initialize game with city data
             * @param {string} cityDataUrl - URL to JSONL city data file
             * @returns {Promise<void>}
             */
            async initialize(cityDataUrl) {
                try {
                    // Load city data
                    const allCities = await DataLoader.loadCityData(cityDataUrl);
                    
                    // Initialize city manager
                    this.cityManager = new CityManager(allCities, this.config.randomSeed);
                    
                    // Select cities
                    this.cityManager.selectCities(this.config.numCities);
                    
                    // Damage cities
                    this.cityManager.damageCities(this.config.damagedFraction);
                    
                    // Initialize scoring engine
                    this.scoringEngine = new ScoringEngine(this.config.advancedMode);
                    
                    // Initialize game state
                    const damagedCities = this.cityManager.getDamagedCities();
                    this.state.transformers = damagedCities.length;
                    this.state.score = 0;
                    this.state.timeRemaining = this.config.timerDuration;
                    this.state.timerStarted = false;
                    this.state.gameEnded = false;
                    
                    console.log(`Game initialized: ${damagedCities.length} cities damaged, ${this.state.transformers} transformers available`);
                    
                } catch (error) {
                    console.error('Failed to initialize game:', error);
                    throw error;
                }
            }

            /**
             * Attempt to restore a city
             * @param {string} cityName - Name of city to restore
             * @returns {Object} Result object with success status and details
             */
            restoreCity(cityName) {
                // Check if game has ended
                if (this.state.gameEnded) {
                    return {
                        success: false,
                        message: 'Game has ended',
                        shouldClearInput: false
                    };
                }
                
                // Find the city
                const city = this.cityManager.findCityByName(cityName);
                
                // Invalid city name - maintain state unchanged
                if (!city) {
                    return {
                        success: false,
                        message: 'City not found',
                        shouldClearInput: false
                    };
                }
                
                // City is not damaged - maintain state unchanged
                if (!city.damaged) {
                    return {
                        success: false,
                        message: 'City is not damaged',
                        shouldClearInput: false
                    };
                }
                
                // City is already restored - maintain state unchanged
                if (city.restored) {
                    return {
                        success: false,
                        message: 'City already restored',
                        shouldClearInput: false
                    };
                }
                
                // Calculate restoration cost
                const restoredCities = this.cityManager.getRestoredCities();
                const cost = this.scoringEngine.calculateRestorationCost(city, restoredCities);
                
                // Check if we have enough transformers
                if (this.state.transformers < cost) {
                    return {
                        success: false,
                        message: 'Not enough transformers',
                        shouldClearInput: false
                    };
                }
                
                // Start timer on first valid restoration
                if (!this.state.timerStarted) {
                    this.startTimer();
                }
                
                // Restore the city
                city.restored = true;
                
                // Update transformers
                this.state.transformers -= cost;
                
                // Calculate and add points
                const points = this.scoringEngine.calculatePoints(city);
                this.state.score += points;
                
                // Check if all cities are restored (win condition)
                const damagedCities = this.cityManager.getDamagedCities();
                if (damagedCities.length === 0) {
                    // All cities restored - end the game
                    this.endGame();
                }
                
                return {
                    success: true,
                    message: `${city.name} restored!`,
                    pointsEarned: points,
                    transformersUsed: cost,
                    shouldClearInput: true
                };
            }

            /**
             * Start the game timer
             */
            startTimer() {
                if (this.state.timerStarted) {
                    return;
                }
                
                this.state.timerStarted = true;
                
                // Update timer every second
                this.timerInterval = setInterval(() => {
                    this.updateTimer();
                }, 1000);
                
                console.log('Timer started');
            }

            /**
             * Update the timer (called every second)
             */
            updateTimer() {
                if (this.state.gameEnded) {
                    return;
                }
                
                this.state.timeRemaining--;
                
                // Update UI if in browser context
                if (typeof updateGameUI === 'function') {
                    updateGameUI();
                }
                
                // Check if time has run out
                if (this.state.timeRemaining <= 0) {
                    this.state.timeRemaining = 0;
                    this.endGame();
                }
            }

            /**
             * End the game
             */
            endGame() {
                if (this.state.gameEnded) {
                    return;
                }
                
                this.state.gameEnded = true;
                
                // Stop the timer
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                console.log('Game ended');
                console.log(`Final score: ${this.state.score}`);
                console.log(`Cities restored: ${this.cityManager.getRestoredCities().length}`);
                
                // Trigger transition to end screen if in browser context
                if (typeof transitionToEndScreen === 'function') {
                    transitionToEndScreen();
                }
            }

            /**
             * Get current game state
             * @returns {Object} Current game state
             */
            getState() {
                return {
                    ...this.state,
                    cities: this.cityManager ? this.cityManager.getCities() : [],
                    damagedCities: this.cityManager ? this.cityManager.getDamagedCities() : [],
                    restoredCities: this.cityManager ? this.cityManager.getRestoredCities() : []
                };
            }

            /**
             * Get cities for map rendering
             * @returns {Array} Array of all cities
             */
            getCities() {
                return this.cityManager ? this.cityManager.getCities() : [];
            }

            /**
             * Get restored cities for map rendering
             * @returns {Array} Array of restored cities
             */
            getRestoredCities() {
                return this.cityManager ? this.cityManager.getRestoredCities() : [];
            }

            /**
             * Check if timer has started
             * @returns {boolean} True if timer has started
             */
            isTimerStarted() {
                return this.state.timerStarted;
            }

            /**
             * Check if game has ended
             * @returns {boolean} True if game has ended
             */
            isGameEnded() {
                return this.state.gameEnded;
            }

            /**
             * Get current score
             * @returns {number} Current score
             */
            getScore() {
                return this.state.score;
            }

            /**
             * Get remaining transformers
             * @returns {number} Remaining transformers
             */
            getTransformers() {
                return this.state.transformers;
            }

            /**
             * Get time remaining
             * @returns {number} Time remaining in seconds
             */
            getTimeRemaining() {
                return this.state.timeRemaining;
            }
        }

        // ============================================
        // Map Rendering
        // ============================================

        /**
         * MapRenderer - Render cities and restoration radius on canvas
         */
        class MapRenderer {
            /**
             * Create a MapRenderer
             * @param {HTMLCanvasElement} canvasElement - Canvas element to render on
             */
            constructor(canvasElement) {
                this.canvas = canvasElement;
                this.ctx = canvasElement.getContext('2d');
                
                // Set canvas size to match display size
                this.resizeCanvas();
                
                // Map projection bounds (US-focused)
                this.bounds = {
                    minLat: 24,   // Southern tip of Florida
                    maxLat: 50,   // Northern border
                    minLon: -125, // West coast
                    maxLon: -65   // East coast
                };
                
                // Padding around the map
                this.padding = 20;
                
                // Store cities for tooltip functionality
                this.cities = [];
                
                // Tooltip state
                this.hoveredCity = null;
                
                // Add mouse move listener for tooltips
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
            }

            /**
             * Draw rough outline of Continental US
             */
            drawCONUSOutline() {
                // Simplified CONUS border points (lat, lon)
                const borderPoints = [
                    // West coast (north to south)
                    [48.5, -124.7], [47.5, -124.5], [46.0, -124.0], [43.0, -124.3],
                    [42.0, -124.4], [40.0, -124.4], [38.0, -123.0], [36.0, -121.5],
                    [34.0, -120.0], [33.0, -117.5], [32.5, -117.1],
                    // Mexico border (west to east)
                    [32.5, -117.1], [32.5, -114.8], [31.5, -111.0], [31.5, -108.2],
                    [31.8, -106.5], [31.8, -104.0], [32.0, -103.0], [29.5, -101.0],
                    [28.0, -99.0], [26.5, -97.5], [26.0, -97.2],
                    // Gulf coast (west to east)
                    [26.0, -97.2], [28.0, -96.5], [29.0, -95.0], [29.5, -94.0],
                    [30.0, -93.5], [30.0, -89.0], [30.5, -88.5], [30.5, -87.5],
                    [30.0, -85.0], [29.0, -84.0], [28.0, -82.5], [25.0, -82.0],
                    // East coast (south to north)
                    [25.5, -80.3], [27.0, -80.0], [29.0, -80.8], [31.0, -81.0],
                    [33.0, -79.0], [34.0, -78.0], [35.5, -75.5], [37.0, -76.0],
                    [38.0, -75.0], [39.5, -74.5], [40.5, -74.0], [41.0, -72.0],
                    [41.5, -71.0], [42.5, -70.5], [43.5, -70.0], [44.5, -67.0],
                    [45.0, -67.0], [47.5, -69.0],
                    // Canada border (east to west)
                    [47.5, -69.0], [47.5, -70.0], [46.0, -71.0], [45.0, -74.5],
                    [45.0, -75.5], [44.5, -76.5], [44.0, -79.0], [43.0, -79.5],
                    [42.5, -82.5], [42.0, -83.5], [46.5, -84.5], [47.0, -87.5],
                    [47.5, -90.0], [48.0, -95.0], [49.0, -95.0], [49.0, -97.0],
                    [49.0, -104.0], [49.0, -111.0], [49.0, -117.0], [49.0, -122.5],
                    [49.0, -124.5], [48.5, -124.7]
                ];

                this.ctx.beginPath();
                borderPoints.forEach((point, index) => {
                    const { x, y } = this.projectToCanvas(point[0], point[1]);
                    if (index === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.closePath();
                this.ctx.strokeStyle = '#999';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }

            /**
             * Handle mouse move for tooltips
             */
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Find city under mouse (within 10 pixels)
                let foundCity = null;
                for (const city of this.cities) {
                    const { x, y } = this.projectToCanvas(city.lat, city.lon);
                    const distance = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                    if (distance <= 10) {
                        foundCity = city;
                        break;
                    }
                }

                // Update tooltip if city changed
                if (foundCity !== this.hoveredCity) {
                    this.hoveredCity = foundCity;
                    this.renderCities(this.cities); // Re-render to show/hide tooltip
                }
            }

            /**
             * Resize canvas to match its display size
             */
            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            /**
             * Convert latitude/longitude to canvas x/y coordinates
             * @param {number} lat - Latitude in degrees
             * @param {number} lon - Longitude in degrees
             * @returns {Object} Object with x and y canvas coordinates
             */
            projectToCanvas(lat, lon) {
                // Calculate normalized position (0 to 1)
                const normalizedX = (lon - this.bounds.minLon) / (this.bounds.maxLon - this.bounds.minLon);
                const normalizedY = (this.bounds.maxLat - lat) / (this.bounds.maxLat - this.bounds.minLat);
                
                // Map to canvas coordinates with padding
                const x = this.padding + normalizedX * (this.canvas.width - 2 * this.padding);
                const y = this.padding + normalizedY * (this.canvas.height - 2 * this.padding);
                
                return { x, y };
            }

            /**
             * Calculate radius in pixels for a given distance in miles
             * @param {number} miles - Distance in miles
             * @returns {number} Radius in pixels
             */
            milesToPixels(miles) {
                // Calculate degrees per mile at approximately 40° latitude (middle of US)
                const degreesPerMile = 1 / 69; // Approximate miles per degree of latitude
                const radiusDegrees = miles * degreesPerMile;
                
                // Convert to pixels using the latitude scale
                const pixelsPerDegree = (this.canvas.height - 2 * this.padding) / (this.bounds.maxLat - this.bounds.minLat);
                return radiusDegrees * pixelsPerDegree;
            }

            /**
             * Clear the canvas
             */
            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            /**
             * Render all cities on the map
             * @param {Array} cities - Array of city objects
             */
            renderCities(cities) {
                console.log(`MapRenderer.renderCities called with ${cities.length} cities`);
                console.log(`Canvas size: ${this.canvas.width}x${this.canvas.height}`);
                
                // Store cities for tooltip functionality
                this.cities = cities;
                
                this.clear();
                
                // Draw CONUS outline
                this.drawCONUSOutline();
                
                // First render all radius circles (so they appear behind cities)
                const restoredCities = cities.filter(city => city.restored);
                console.log(`Rendering ${restoredCities.length} restored cities with radius circles`);
                this.renderRadiusCircles(restoredCities);
                
                // Then render all cities
                cities.forEach(city => {
                    this.renderCity(city);
                });
                
                // Render city labels if less than 100 cities
                if (cities.length < 100) {
                    cities.forEach(city => {
                        this.renderCityLabel(city);
                    });
                }
                
                // Render tooltip for hovered city
                if (this.hoveredCity) {
                    this.renderTooltip(this.hoveredCity);
                }
                
                console.log('Map rendering complete');
            }

            /**
             * Render city label
             * @param {Object} city - City object
             */
            renderCityLabel(city) {
                const { x, y } = this.projectToCanvas(city.lat, city.lon);
                
                this.ctx.font = '10px Arial';
                this.ctx.fillStyle = '#333';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(city.name, x, y - 8);
            }

            /**
             * Render tooltip for a city
             * @param {Object} city - City object
             */
            renderTooltip(city) {
                const { x, y } = this.projectToCanvas(city.lat, city.lon);
                
                // Tooltip content
                const lines = [
                    city.name,
                    `Pop: ${city.population.toFixed(1)}k`,
                    city.restored ? 'Restored' : (city.damaged ? 'Damaged' : 'Undamaged')
                ];
                
                // Measure text
                this.ctx.font = '12px Arial';
                const maxWidth = Math.max(...lines.map(line => this.ctx.measureText(line).width));
                const padding = 8;
                const lineHeight = 16;
                const tooltipWidth = maxWidth + padding * 2;
                const tooltipHeight = lines.length * lineHeight + padding;
                
                // Position tooltip (offset from city)
                let tooltipX = x + 15;
                let tooltipY = y - tooltipHeight / 2;
                
                // Keep tooltip on screen
                if (tooltipX + tooltipWidth > this.canvas.width) {
                    tooltipX = x - tooltipWidth - 15;
                }
                if (tooltipY < 0) tooltipY = 0;
                if (tooltipY + tooltipHeight > this.canvas.height) {
                    tooltipY = this.canvas.height - tooltipHeight;
                }
                
                // Draw tooltip background
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                this.ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                this.ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                
                // Draw tooltip text
                this.ctx.fillStyle = '#333';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'left';
                lines.forEach((line, index) => {
                    this.ctx.fillText(line, tooltipX + padding, tooltipY + padding + (index + 1) * lineHeight - 4);
                });
            }

            /**
             * Render a single city
             * @param {Object} city - City object with lat, lon, damaged, and restored properties
             */
            renderCity(city) {
                const { x, y } = this.projectToCanvas(city.lat, city.lon);
                
                // Determine city color based on state
                let color;
                if (city.restored) {
                    color = '#2ecc71'; // Green for restored
                } else if (city.damaged) {
                    color = '#e74c3c'; // Red for damaged
                } else {
                    color = '#3498db'; // Blue for undamaged
                }
                
                // Calculate radius based on square root of population
                // This makes area proportional to population
                const minRadius = 3;
                const maxRadius = minRadius * 3; // 9 pixels
                
                // Normalize population to [0, 1] range using square root
                // Assuming population ranges from ~250 to ~20000
                const minPop = 250;
                const maxPop = 20000;
                const normalizedPop = Math.sqrt(Math.max(minPop, Math.min(maxPop, city.population))) / Math.sqrt(maxPop);
                
                // Scale to radius range
                const radius = minRadius + normalizedPop * (maxRadius - minRadius);
                
                // Draw city circle
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
                this.ctx.fillStyle = color;
                this.ctx.fill();
                
                // Add border for better visibility
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }

            /**
             * Render 300-mile radius circles around restored cities
             * @param {Array} restoredCities - Array of restored city objects
             */
            renderRadiusCircles(restoredCities) {
                restoredCities.forEach(city => {
                    const { x, y } = this.projectToCanvas(city.lat, city.lon);
                    const radius = this.milesToPixels(300);
                    
                    // Draw radius circle
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    this.ctx.strokeStyle = 'rgba(46, 204, 113, 0.3)'; // Semi-transparent green
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // Fill with very light green
                    this.ctx.fillStyle = 'rgba(46, 204, 113, 0.1)';
                    this.ctx.fill();
                });
            }

            /**
             * Update a single city's rendering (for incremental updates)
             * @param {Object} city - City object to update
             * @param {Array} allCities - All cities (needed for full re-render)
             */
            updateCity(city, allCities) {
                // For simplicity, re-render all cities
                // This ensures radius circles and overlapping cities are handled correctly
                this.renderCities(allCities);
            }
        }

        // ============================================
        // DynamoDB Integration
        // ============================================

        /**
         * DynamoDBClient - Handle score persistence to AWS DynamoDB
         * Requires AWS SDK to be loaded from CDN
         */
        class DynamoDBClient {
            /**
             * Create a DynamoDBClient
             * @param {Object} credentials - AWS credentials object
             * @param {string} credentials.accessKeyId - AWS access key ID
             * @param {string} credentials.secretAccessKey - AWS secret access key
             * @param {string} credentials.region - AWS region (e.g., 'us-east-1')
             */
            constructor(credentials) {
                if (!credentials || !credentials.accessKeyId || !credentials.secretAccessKey || !credentials.region) {
                    throw new Error('Invalid AWS credentials: accessKeyId, secretAccessKey, and region are required');
                }

                this.credentials = credentials;
                this.tableName = 'shimonopoly-scores';
                this.dynamoDB = null;
                this.docClient = null;
                
                // Initialize AWS SDK if available
                this.initializeAWS();
            }

            /**
             * Initialize AWS SDK with credentials
             */
            initializeAWS() {
                try {
                    // Check if AWS SDK is loaded
                    if (typeof AWS === 'undefined') {
                        throw new Error('AWS SDK not loaded. Please include the AWS SDK script in your HTML.');
                    }

                    // Configure AWS credentials
                    AWS.config.update({
                        accessKeyId: this.credentials.accessKeyId,
                        secretAccessKey: this.credentials.secretAccessKey,
                        region: this.credentials.region
                    });

                    // Create DynamoDB clients
                    this.dynamoDB = new AWS.DynamoDB();
                    this.docClient = new AWS.DynamoDB.DocumentClient();
                    
                    console.log('AWS SDK initialized successfully');
                } catch (error) {
                    console.error('Failed to initialize AWS SDK:', error);
                    throw error;
                }
            }

            /**
             * Store a score record in DynamoDB
             * @param {Object} record - Score record to store
             * @param {string} record.playerName - Player's name
             * @param {number} record.score - Final score
             * @param {number} record.timestamp - Unix timestamp
             * @param {Object} record.config - Game configuration
             * @returns {Promise<void>}
             */
            async storeScore(record) {
                try {
                    // Validate record
                    if (!record || !record.playerName || typeof record.score !== 'number' || 
                        !record.timestamp || !record.config) {
                        throw new Error('Invalid score record: playerName, score, timestamp, and config are required');
                    }

                    // Generate a unique game ID
                    const gameId = this.generateGameId();

                    // Prepare DynamoDB item
                    const item = {
                        gameId: gameId,
                        timestamp: record.timestamp,
                        playerName: record.playerName,
                        score: record.score,
                        citiesRestored: record.citiesRestored || 0,
                        config: {
                            numCities: record.config.numCities,
                            damagedFraction: record.config.damagedFraction,
                            timerDuration: record.config.timerDuration,
                            advancedMode: record.config.advancedMode,
                            randomSeed: record.config.randomSeed
                        }
                    };

                    // Store in DynamoDB
                    const params = {
                        TableName: this.tableName,
                        Item: item
                    };

                    await this.docClient.put(params).promise();
                    
                    console.log('Score stored successfully:', item);
                } catch (error) {
                    console.error('Failed to store score:', error);
                    
                    // Provide user-friendly error messages
                    if (error.code === 'ResourceNotFoundException') {
                        throw new Error(`DynamoDB table '${this.tableName}' not found. Please create the table first.`);
                    } else if (error.code === 'UnrecognizedClientException' || error.code === 'InvalidSignatureException') {
                        throw new Error('Invalid AWS credentials. Please check your access key and secret key.');
                    } else if (error.code === 'NetworkingError' || error.code === 'TimeoutError') {
                        throw new Error('Network error: Unable to connect to DynamoDB. Please check your internet connection.');
                    } else {
                        throw new Error(`Failed to save score: ${error.message}`);
                    }
                }
            }

            /**
             * Retrieve top scores from DynamoDB
             * @param {number} limit - Maximum number of scores to retrieve
             * @param {boolean} advancedMode - Filter by advanced mode (optional)
             * @returns {Promise<Array>} Array of score records
             */
            async getTopScores(limit = 10, advancedMode = null) {
                try {
                    // If advancedMode filter is specified, use the GSI
                    if (advancedMode !== null) {
                        const params = {
                            TableName: this.tableName,
                            IndexName: 'score-index',
                            KeyConditionExpression: 'advancedMode = :mode',
                            ExpressionAttributeValues: {
                                ':mode': advancedMode
                            },
                            ScanIndexForward: false, // Sort descending by score
                            Limit: limit
                        };

                        const result = await this.docClient.query(params).promise();
                        return result.Items || [];
                    } else {
                        // Without filter, scan the table and sort by score
                        // Note: This is less efficient for large tables
                        const params = {
                            TableName: this.tableName,
                            Limit: 100 // Scan more items to find top scores
                        };

                        const result = await this.docClient.scan(params).promise();
                        const items = result.Items || [];
                        
                        // Sort by score descending and take top N
                        items.sort((a, b) => b.score - a.score);
                        return items.slice(0, limit);
                    }
                } catch (error) {
                    console.error('Failed to retrieve scores:', error);
                    
                    // Provide user-friendly error messages
                    if (error.code === 'ResourceNotFoundException') {
                        throw new Error(`DynamoDB table '${this.tableName}' not found. Please create the table first.`);
                    } else if (error.code === 'UnrecognizedClientException' || error.code === 'InvalidSignatureException') {
                        throw new Error('Invalid AWS credentials. Please check your access key and secret key.');
                    } else if (error.code === 'NetworkingError' || error.code === 'TimeoutError') {
                        throw new Error('Network error: Unable to connect to DynamoDB. Please check your internet connection.');
                    } else {
                        throw new Error(`Failed to retrieve scores: ${error.message}`);
                    }
                }
            }

            /**
             * Generate a unique game ID
             * @returns {string} UUID v4 string
             */
            generateGameId() {
                // Simple UUID v4 generator
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            /**
             * Test connection to DynamoDB
             * @returns {Promise<boolean>} True if connection is successful
             */
            async testConnection() {
                try {
                    // Try to describe the table
                    const params = {
                        TableName: this.tableName
                    };
                    
                    await this.dynamoDB.describeTable(params).promise();
                    return true;
                } catch (error) {
                    console.error('Connection test failed:', error);
                    return false;
                }
            }
        }

        // ============================================
        // Application Initialization
        // ============================================

        // Global game state
        let gameController = null;
        let mapRenderer = null;
        let dynamoDBClient = null;

        // ============================================
        // Setup Screen Event Handlers
        // ============================================

        /**
         * Validate damage fraction input
         * @param {number} fraction - Fraction value to validate
         * @returns {boolean} True if valid
         */
        function validateDamageFraction(fraction) {
            return fraction >= 0.5 && fraction <= 1.0;
        }

        /**
         * Validate all setup form inputs
         * @returns {Object} Validation result with isValid flag and errors object
         */
        function validateSetupForm() {
            const errors = {};
            let isValid = true;

            // Get form values
            const playerName = document.getElementById('playerName').value.trim();
            const randomSeed = parseInt(document.getElementById('randomSeed').value);
            const numCities = parseInt(document.getElementById('numCities').value);
            const damagedFraction = parseFloat(document.getElementById('damagedFraction').value);
            const timerDuration = parseInt(document.getElementById('timerDuration').value);

            // Validate player name
            if (!playerName) {
                errors.playerName = 'Player name is required';
                isValid = false;
            }

            // Validate random seed
            if (isNaN(randomSeed)) {
                errors.randomSeed = 'Random seed must be a number';
                isValid = false;
            }

            // Validate number of cities
            if (isNaN(numCities) || numCities <= 0) {
                errors.numCities = 'Number of cities must be greater than 0';
                isValid = false;
            }

            // Validate damage fraction
            if (isNaN(damagedFraction) || !validateDamageFraction(damagedFraction)) {
                errors.damagedFraction = 'Fraction must be between 0.5 and 1.0';
                isValid = false;
            }

            // Validate timer duration
            if (isNaN(timerDuration) || timerDuration <= 0) {
                errors.timerDuration = 'Timer duration must be greater than 0';
                isValid = false;
            }

            return { isValid, errors };
        }

        /**
         * Display validation errors on the form
         * @param {Object} errors - Object with field names as keys and error messages as values
         */
        function displayValidationErrors(errors) {
            // Clear all existing error messages
            document.querySelectorAll('.error-message').forEach(el => {
                el.classList.remove('show');
            });

            // Display new error messages
            if (errors.damagedFraction) {
                const errorEl = document.getElementById('damagedFractionError');
                errorEl.textContent = errors.damagedFraction;
                errorEl.classList.add('show');
            }

            // For other fields, we could add error message elements if needed
            // For now, we'll use console logging for non-damage-fraction errors
            Object.keys(errors).forEach(field => {
                if (field !== 'damagedFraction') {
                    console.error(`Validation error for ${field}: ${errors[field]}`);
                }
            });
        }

        /**
         * Parse AWS credentials from JSON textarea
         * @returns {Object|null} Credentials object or null if empty/invalid
         */
        function parseAWSCredentials() {
            const credentialsText = document.getElementById('awsCredentials').value.trim();
            
            if (!credentialsText) {
                return null; // No credentials provided
            }

            try {
                const credentials = JSON.parse(credentialsText);
                
                // Validate required fields
                if (!credentials.accessKeyId || !credentials.secretAccessKey || !credentials.region) {
                    throw new Error('Missing required fields: accessKeyId, secretAccessKey, region');
                }

                return credentials;
            } catch (error) {
                throw new Error(`Invalid AWS credentials JSON: ${error.message}`);
            }
        }

        /**
         * Start the game with validated configuration
         */
        async function startGame() {
            try {
                // Validate form
                const validation = validateSetupForm();
                
                if (!validation.isValid) {
                    displayValidationErrors(validation.errors);
                    return;
                }

                // Clear any previous errors
                displayValidationErrors({});

                // Get form values
                const config = {
                    playerName: document.getElementById('playerName').value.trim(),
                    country: document.getElementById('country').value,
                    randomSeed: parseInt(document.getElementById('randomSeed').value),
                    numCities: parseInt(document.getElementById('numCities').value),
                    damagedFraction: parseFloat(document.getElementById('damagedFraction').value),
                    timerDuration: parseInt(document.getElementById('timerDuration').value),
                    advancedMode: document.getElementById('advancedMode').checked
                };

                // Parse AWS credentials if provided
                try {
                    const awsCredentials = parseAWSCredentials();
                    if (awsCredentials) {
                        config.awsCredentials = awsCredentials;
                        // Initialize DynamoDB client
                        dynamoDBClient = new DynamoDBClient(awsCredentials);
                    }
                } catch (error) {
                    alert(`AWS Credentials Error: ${error.message}\n\nThe game will start without score saving functionality.`);
                    dynamoDBClient = null;
                }

                // Disable start button to prevent double-clicks
                const startButton = document.getElementById('startButton');
                startButton.disabled = true;
                startButton.textContent = 'Loading...';

                // Initialize game controller
                gameController = new GameController(config);
                
                // Determine which data file to load based on country selection
                const dataFile = config.country === 'world' ? 'kaggle_worldcities.jsonl' : 'usmetros.jsonl';
                
                // Load city data and initialize game
                await gameController.initialize(dataFile);

                // Initialize map renderer
                const canvas = document.getElementById('gameCanvas');
                mapRenderer = new MapRenderer(canvas);

                // Transition to game screen
                transitionToGameScreen();

            } catch (error) {
                console.error('Failed to start game:', error);
                alert(`Failed to start game: ${error.message}`);
                
                // Re-enable start button
                const startButton = document.getElementById('startButton');
                startButton.disabled = false;
                startButton.textContent = 'Start Game';
            }
        }

        /**
         * Transition from setup screen to game screen
         */
        function transitionToGameScreen() {
            // Hide setup screen
            document.getElementById('setupScreen').classList.remove('active');
            
            // Show game screen
            document.getElementById('gameScreen').classList.add('active');

            // Resize canvas now that it's visible
            mapRenderer.resizeCanvas();

            // Initialize game UI
            updateGameUI();
            
            // Render initial map
            const cities = gameController.getCities();
            console.log(`Rendering ${cities.length} cities on map`);
            mapRenderer.renderCities(cities);

            // Focus on city input
            document.getElementById('cityInput').focus();
        }

        // Attach event listener to start button
        document.getElementById('startButton').addEventListener('click', startGame);

        // Add toggle for advanced settings
        const advancedSettingsToggle = document.getElementById('advancedSettingsToggle');
        advancedSettingsToggle.addEventListener('click', function() {
            const advancedSettings = document.getElementById('advancedSettings');
            const isShown = advancedSettings.classList.toggle('show');
            this.textContent = isShown ? 'Hide settings' : 'More settings';
        });
        
        // Prevent toggle button from capturing Enter key
        advancedSettingsToggle.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                e.stopPropagation();
            }
        });

        // Add real-time validation for damage fraction
        document.getElementById('damagedFraction').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            const errorEl = document.getElementById('damagedFractionError');
            
            if (isNaN(value) || !validateDamageFraction(value)) {
                errorEl.classList.add('show');
            } else {
                errorEl.classList.remove('show');
            }
        });

        // Allow Enter key to submit form
        document.getElementById('setupScreen').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
                e.stopPropagation();
                startGame();
            }
        });

        // ============================================
        // Game Screen Event Handlers
        // ============================================

        /**
         * Update game UI displays (timer, score, transformers)
         */
        function updateGameUI() {
            // Update timer display
            const timeRemaining = gameController.getTimeRemaining();
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            document.getElementById('timerDisplay').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Update score display
            const score = gameController.getScore();
            document.getElementById('scoreDisplay').textContent = 
                gameController.config.advancedMode ? score.toFixed(1) : score;

            // Update transformers display
            const transformers = gameController.getTransformers();
            document.getElementById('transformersDisplay').textContent = 
                gameController.config.advancedMode ? transformers.toFixed(2) : transformers;
        }

        /**
         * Handle city restoration attempt
         */
        function handleCitySubmit() {
            console.log('handleCitySubmit called');
            
            if (!gameController) {
                console.error('gameController is null!');
                return;
            }
            
            if (gameController.isGameEnded()) {
                console.log('Game has ended, ignoring input');
                return;
            }

            const cityInput = document.getElementById('cityInput');
            const cityName = cityInput.value.trim();

            console.log(`Attempting to restore: "${cityName}"`);

            if (!cityName) {
                console.log('Empty city name, ignoring');
                return;
            }

            // Attempt to restore the city
            const result = gameController.restoreCity(cityName);
            console.log('Restore result:', result);

            // Clear input if restoration was successful
            if (result.shouldClearInput) {
                cityInput.value = '';
                cityInput.style.color = 'black'; // Reset color
            }

            // Update UI
            updateGameUI();

            // Update map
            const cities = gameController.getCities();
            mapRenderer.renderCities(cities);

            // Check if game has ended
            if (gameController.isGameEnded()) {
                transitionToEndScreen();
            }
        }

        /**
         * Transition from game screen to end screen
         */
        function transitionToEndScreen() {
            // Hide game screen
            document.getElementById('gameScreen').classList.remove('active');
            
            // Show end screen
            document.getElementById('endScreen').classList.add('active');

            // Display final score and cities restored
            const finalScore = gameController.getScore();
            const citiesRestored = gameController.getRestoredCities().length;
            const totalDamagedCities = gameController.cityManager.cities.filter(c => c.damaged).length;
            
            // Check if all cities were restored
            const allCitiesRestored = citiesRestored === totalDamagedCities;
            
            // Update title based on completion
            const titleEl = document.getElementById('endScreenTitle');
            if (allCitiesRestored) {
                titleEl.textContent = 'Congratulations - you fixed them all!';
                // Show fireworks for 10 seconds
                showFireworks();
                setTimeout(() => {
                    hideFireworks();
                }, 10000);
            } else {
                titleEl.textContent = 'Good game';
            }

            document.getElementById('finalScore').textContent = 
                gameController.config.advancedMode ? finalScore.toFixed(1) : finalScore;
            document.getElementById('citiesRestored').textContent = citiesRestored;

            // Show save score button if AWS credentials are available
            if (dynamoDBClient) {
                document.getElementById('saveScoreButton').style.display = 'block';
            }

            // Load leaderboard if AWS credentials are available
            if (dynamoDBClient) {
                loadLeaderboard();
            }
        }

        /**
         * Show fireworks animation
         */
        function showFireworks() {
            const fireworksContainer = document.getElementById('fireworks');
            fireworksContainer.style.display = 'block';
            
            // Create fireworks at intervals
            const fireworkInterval = setInterval(() => {
                createFirework();
            }, 300);
            
            // Store interval ID to clear it later
            fireworksContainer.dataset.intervalId = fireworkInterval;
        }

        /**
         * Hide fireworks animation
         */
        function hideFireworks() {
            const fireworksContainer = document.getElementById('fireworks');
            const intervalId = fireworksContainer.dataset.intervalId;
            
            if (intervalId) {
                clearInterval(parseInt(intervalId));
            }
            
            fireworksContainer.style.display = 'none';
            fireworksContainer.innerHTML = '';
        }

        /**
         * Create a single firework explosion
         */
        function createFirework() {
            const fireworksContainer = document.getElementById('fireworks');
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500'];
            
            // Random position
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * (window.innerHeight * 0.6); // Top 60% of screen
            
            // Create particles
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'firework';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                
                // Random direction
                const angle = (Math.PI * 2 * i) / particleCount;
                const velocity = 50 + Math.random() * 100;
                const tx = Math.cos(angle) * velocity;
                const ty = Math.sin(angle) * velocity;
                
                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');
                
                fireworksContainer.appendChild(particle);
                
                // Remove particle after animation
                setTimeout(() => {
                    particle.remove();
                }, 1000);
            }
        }

        /**
         * Load and display leaderboard
         */
        async function loadLeaderboard() {
            try {
                const scores = await dynamoDBClient.getTopScores(10, gameController.config.advancedMode);
                
                if (scores.length > 0) {
                    const leaderboardDiv = document.getElementById('leaderboard');
                    const entriesDiv = document.getElementById('leaderboardEntries');
                    
                    // Clear existing entries
                    entriesDiv.innerHTML = '';
                    
                    // Add score entries
                    scores.forEach((score, index) => {
                        const entry = document.createElement('div');
                        entry.className = 'leaderboard-entry';
                        entry.innerHTML = `
                            <span>${index + 1}. ${score.playerName}</span>
                            <span>${gameController.config.advancedMode ? score.score.toFixed(1) : score.score}</span>
                        `;
                        entriesDiv.appendChild(entry);
                    });
                    
                    // Show leaderboard
                    leaderboardDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('Failed to load leaderboard:', error);
                const errorEl = document.getElementById('endScreenError');
                errorEl.textContent = `Failed to load leaderboard: ${error.message}`;
                errorEl.classList.add('show');
            }
        }

        /**
         * Save score to DynamoDB
         */
        async function saveScore() {
            try {
                const saveButton = document.getElementById('saveScoreButton');
                saveButton.disabled = true;
                saveButton.textContent = 'Saving...';

                const record = {
                    playerName: gameController.config.playerName,
                    score: gameController.getScore(),
                    timestamp: Date.now(),
                    citiesRestored: gameController.getRestoredCities().length,
                    config: gameController.config
                };

                await dynamoDBClient.storeScore(record);
                
                saveButton.textContent = 'Saved!';
                
                // Reload leaderboard to show updated scores
                await loadLeaderboard();
                
            } catch (error) {
                console.error('Failed to save score:', error);
                const errorEl = document.getElementById('endScreenError');
                errorEl.textContent = `Failed to save score: ${error.message}`;
                errorEl.classList.add('show');
                
                const saveButton = document.getElementById('saveScoreButton');
                saveButton.disabled = false;
                saveButton.textContent = 'Save Score';
            }
        }

        /**
         * Restart the game
         */
        function playAgain() {
            // Reset global state
            gameController = null;
            mapRenderer = null;
            
            // Hide end screen
            document.getElementById('endScreen').classList.remove('active');
            
            // Show setup screen
            document.getElementById('setupScreen').classList.add('active');
            
            // Re-enable start button
            const startButton = document.getElementById('startButton');
            startButton.disabled = false;
            startButton.textContent = 'Start Game';
            
            // Clear any error messages
            document.querySelectorAll('.error-message').forEach(el => {
                el.classList.remove('show');
            });
            
            // Focus player name field so Enter key works
            document.getElementById('playerName').focus();
        }

        // Attach event listeners for game screen
        const submitButton = document.getElementById('submitCity');
        if (submitButton) {
            submitButton.addEventListener('click', handleCitySubmit);
            console.log('Submit button event listener attached');
        } else {
            console.error('Submit button not found!');
        }
        
        const cityInput = document.getElementById('cityInput');
        if (cityInput) {
            // Handle Enter key
            cityInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleCitySubmit();
                }
            });
            
            // Real-time validation with color feedback
            cityInput.addEventListener('input', function(e) {
                if (!gameController || !gameController.cityManager) {
                    return;
                }
                
                const input = e.target.value.trim().toLowerCase();
                
                if (!input) {
                    e.target.style.color = 'black';
                    return;
                }
                
                const cities = gameController.getCities();
                const damagedCities = cities.filter(c => c.damaged && !c.restored);
                
                // Check for exact match
                const exactMatch = damagedCities.find(city => 
                    city.name.toLowerCase() === input
                );
                
                if (exactMatch) {
                    e.target.style.color = 'green';
                    return;
                }
                
                // Check for partial matches
                const partialMatches = damagedCities.filter(city =>
                    city.name.toLowerCase().includes(input)
                );
                
                if (partialMatches.length > 0) {
                    e.target.style.color = 'black';
                } else {
                    e.target.style.color = 'red';
                }
            });
            
            console.log('City input event listeners attached');
        } else {
            console.error('City input not found!');
        }

        // Attach event listeners for end screen
        document.getElementById('saveScoreButton').addEventListener('click', saveScore);
        document.getElementById('playAgainButton').addEventListener('click', playAgain);

        // Auto-focus the player name field on page load so Enter key works immediately
        document.getElementById('playerName').focus();

        console.log('Shimonopoly initialized');
        console.log('SeededRandom, DistanceCalculator, DataLoader, CityManager, ScoringEngine, GameController, MapRenderer, and DynamoDBClient classes loaded');
    </script>
</body>
</html>
